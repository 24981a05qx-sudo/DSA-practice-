#Given n roses and an array nums where nums[i] denotes that the 'ith' rose will bloom on the nums[i]th day, 
# only adjacent bloomed roses can be picked to make a bouquet. 
# Exactly k adjacent bloomed roses are required to make a single bouquet.
#  Find the minimum number of days required to make at least m bouquets, each containing k roses. Return -1 if it is not possible.

#Example 1

#Input: n = 8, nums = [7, 7, 7, 7, 13, 11, 12, 7], m = 2, k = 3
#Output: 12
#Explanation: On the 12th the first 4 flowers and the last 3 flowers would have already bloomed. So, we can easily make 2 bouquets, one with the first 3 and another with the last 3 flowers.

#Example 2

#Input: n = 5, nums = [1, 10, 3, 10, 2], m = 3, k = 2
#Output: -1
#xplanation: If we want to make 3 bouquets of 2 flowers each, we need at least 6 flowers. But we are given only 5 flowers, so, we cannot make the bouquets.




n = int(input("Enter number of roses: "))
nums = list(map(int, input("Enter bloom days separated by space: ").split()))
m = int(input("Enter number of bouquets required: "))
k = int(input("Enter roses per bouquet: "))


if m * k > n:
    print(-1)
else:
    left = min(nums)
    right = max(nums)
    ans = -1


    while left <= right:
        mid = (left + right) // 2
        bouquets = 0
        count = 0

     
        for i in range(n):
            if nums[i] <= mid:
                count += 1
                if count == k:
                    bouquets += 1
                    count = 0
            else:
                count = 0

        if bouquets >= m:
            ans = mid
            right = mid - 1
        else:
            left = mid + 1

    print(ans)
     



